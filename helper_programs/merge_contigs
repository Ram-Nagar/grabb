#!/usr/bin/perl -w
use strict;

########################################################################
#                         merge_contigs.pl                             #
# # # # # # # # # # # # # # # # # ## # # # # # # # # # # # # # # # # # #
# This program reads the contigs from a fasta file and checks if they  #
# are overlaping with each other by using a minimal overlap size that  #
# is specified at invocation. Afterwards it loops through all the      #
# contigs and merges contig pairs that only overlap with each other at #
# the given side. In the end it saves the contigs that were created    #
# into a file.                                                         #
########################################################################



# Get the input
# Print usage message if not right number of inputs
die "Usage:\n\t$0 <contigs.fasta> <overlap> <output.fas>\n" unless scalar @ARGV == 3;

# Inputs: fasta file, minimum length of overlap and output file
my ($in, $len, $out) = @ARGV;

# Load fasta file into a hash (keys: ids and values: sequences)
my %fasta;
&fasta2hash(\$in, \%fasta, []);

# Create a contig object for each entry in the fasta file
# Store the contigs in an array
my @contigs;
for (keys %fasta) {
    my $seq = $fasta{$_};
    # Create the contig with the id name as name
    push @contigs, contig->new($_, $seq);
}

# Find overlaps between them
#    The overlap information is stored inside the contig objects
&test_overlaps(\@contigs);

# An array to hold circularised contigs and at the end all the final contigs
my @final;

# Loop until there are no mergers to be done
my $change++;
while ($change) {
    # Make $change undef so if nothing happens the loop is broken
    $change = undef;
    
    # Print the number of contigs that are still tested (not in @final)
    print "# of contigs: " . scalar @contigs . "\n";
    
    # Loop throug the contigs
    for my $a (@contigs) {
    
        # Get the name of the contig
        my $contig1 = $a->name();
        
        # Get the list of overlaps for the 5' end
        my @list = @{ $a->get_before() };
        
        # Check if there is only one overlap ELSE proceed to the 3' end
        if (scalar @list == 1) {
        
            # Get the overlap size
            my $overlap = $list[0]->[0];
            
            # Get the overlaping contig object
            my $b = $list[0]->[1];
            
            # Get the name of the overlaping contig
            my $contig2 = $b->name();
            
            # True if the overlap is in reverse orientation
            my $rev++ if $list[0]->[2] eq "-";
            
            # Check if there is only one overlap at the corresponding end of the partner
            my @second;
            if ($rev) {
                # If the orientation is reverse than get the 5' end of the partner
                @second = @{ $b->get_before() };
            } else {
                # ELSE get the 3' end of the partner
                @second = @{ $b->get_after() };
            }
            
            # Do the actual check
            if (scalar @second == 1) {
                # They are mutually exclusive continuetion of each other
                
                # If it overlaps with itsself but in the reverse orientation skip to the next
                next if ($contig1 eq $contig2 && $rev);
                
                # Collect the rest of the active contigs into an array
                my @new = grep{$_ ne $a && $_ ne $b} @contigs;
                
                # If they are two different contigs then join them and add the new contig to the active contigs array
                if ($contig1 ne $contig2) {
                    
                    # Print the fact that two contigs are getting merged
                    print "Merging: $contig1 and $contig2 => $contig2 (overlap: $overlap)\n";
                    
                    # Add the merged contig the new contig to tha active contigs array
                    #    merge_pair returns a contig object
                    push @new, &merge_pair($b, $a, $overlap, $rev, undef);
                } else {
                    # Print the fact that a contig is being circularised
                    print "Merging: $contig1 and $contig2 => $contig1 circular (overlap: $overlap)\n";
                    
                    # Add the merged/circularised contig to the final array
                    push @final, contig->new("$contig1 circular", substr $a->seq(), $overlap);
                }
                
                # Reinitialise the contigs and get the new overlaps for the next round
                @contigs = @{ &new_contigs(\@new)};
                
                # Mark that there has been a change
                $change++;
                
                # Jump back to the while loop
                last;
            }
        } else {
            
            # Get the list of overlaps for the 3' end
            my @other_list = @{ $a->get_after() };
            
            # Check if there is only one overlap ELSE proceed to the next contig
            if (scalar @other_list == 1) {
                
                # Get the overlap size
                my $overlap = $other_list[0]->[0];
            
                # Get the overlaping contig object
                my $b = $other_list[0]->[1];
            
                # Get the name of the overlaping contig
                my $contig2 = $b->name();
            
                # True if the overlap is in reverse orientation
                my $rev++ if $other_list[0]->[2] eq "-";
            
                # Check if there is only one overlap at the corresponding end of the partner
                my @second;
                if ($rev) {
                    # If the orientation is reverse than get the 3' end of the partner
                    @second = @{ $b->get_after() };
                } else {
                    # ELSE get the 5' end of the partner
                    @second = @{ $b->get_before() };
                }
            
                # Check if they are mutually exclusive continuetion of each other
                if (scalar @second == 1) {
                    
                    # Collect the rest of the active contigs into an array
                    my @new = grep{$_ ne $a && $_ ne $b} @contigs;
                    
                    # If they are two different contigs then join them and add the new contig to the active contigs array
                    if ($contig1 ne $contig2) {
                        
                        # Print the fact that two contigs are getting merged
                        print "Merging: $contig1 and $contig2 => $contig1 (overlap: $overlap)\n";
                        
                        # Add the merged contig the new contig to tha active contigs array
                        #    merge_pair returns a contig object
                        push @new, &merge_pair($a, $b, $overlap, undef, $rev);
                    } else {
                    
                        # Print the fact that a contig is being circularised
                        print "Merging: $contig1 and $contig2 => $contig1 circular (overlap: $overlap)\n";
                        
                        # Add the merged/circularised contig to the final array
                        push @final, contig->new("$contig1 circular", substr $a->seq(), $overlap);
                    }
                    # Reinitialise the contigs and get the new overlaps for the next round
                    @contigs = @{ &new_contigs(\@new)};
                
                    # Mark that there has been a change
                    $change++;
                
                    # Jump back to the while loop
                    last;
                }
            }
        }
    } # For loop
} # While loop

# Open the file handle for the output file
open my $to, '>', $out;

# Add the still active contigs to the circularised contig list
@final = (@final, @contigs);

# Print the contigs to the output file
for (@final) {
    print {$to} &to_fasta($_->name(), $_->seq());
}

# Close the output file handle
close $to;

#############################
# Subroutines and packages  #
#############################


###############################################################################################################
sub fasta2hash{                                                                                               # fasta2hash
    # This subroutine reads in a fasta file (input) and saves it into a hash (output), saves ids to an array  # fasta2hash
    #    keys: ids    values: sequences                                                                       # fasta2hash
    #     Inputs:                                                                                             # fasta2hash
    my ($file_ref,    # Refence to the FASTA file                                                             # fasta2hash
        $hash_ref,    # Refernce to the hash variable that will hold the entries of the Fasta file            # fasta2hash
                      #    keys: id line        values: the corresponding sequnce                             # fasta2hash
        $order_ref    # Refernce to an array that stores the order of the entries (elements are the id lines) # fasta2hash
                      ) = @_;                                                                                 # fasta2hash
                                                                                                              # fasta2hash
    # A scalar variable to store the id of the current entry                                                  # fasta2hash
    my $current;                                                                                              # fasta2hash
                                                                                                              # fasta2hash
    # Open the FASTA file for reading, then read the file in line by line                                     # fasta2hash
    open my $fasta, '<', $$file_ref;                                                                          # fasta2hash
    for (<$fasta>) {                                                                                          # fasta2hash
        s/\R//g;                           # Remove line endings                                              # fasta2hash
        next if /^\s*$/;                   # Skip empty lines                                                 # fasta2hash
        if (/^>(.*)/) {                    # Get the ID                                                       # fasta2hash
            $current = $1;                 # save the ID                                                      # fasta2hash
            push @$order_ref, $current;    # save the ID in the order array                                   # fasta2hash
        } else {                                                                                              # fasta2hash
	    die "ERROR: the input is not correct FASTA format\n" unless $current;
            $$hash_ref{$current} .= $_;    # append line to the current sequence                              # fasta2hash
        }                                                                                                     # fasta2hash
    }                                                                                                         # fasta2hash
    close $fasta;                                                                                             # fasta2hash
}                                                                                                             # fasta2hash
###############################################################################################################
sub to_fasta {                                                                                                # to_fasta
    # This subroutin takes two inputs: sequence id and sequence and returns a fasta formated string           # to_fasta
    my ($seq_name, $seq) = @_;                                                                                # to_fasta
    # The first line is the id line                                                                           # to_fasta
    my $formatted_seq = ">$seq_name\n";                                                                       # to_fasta
    my $count = 0;                                                                                            # to_fasta
    # The rest is the sequence, with a maximal line length of 60                                              # to_fasta
    while (my $chunk = substr($seq, 0, 60, "")) {                                                             # to_fasta
        $formatted_seq .= "$chunk\n";                                                                         # to_fasta
    }                                                                                                         # to_fasta
    # Return the string                                                                                       # to_fasta
    return $formatted_seq;                                                                                    # to_fasta
}                                                                                                             # to_fasta
###############################################################################################################
sub test_overlaps{                                                                                            # test_overlaps
    # This subroutine takes an array refernce as input, elements of the array are contig objects              # test_overlaps
    #    This subroutine tests the overlap between each pair of contigs for both ends of the contig           # test_overlaps
    my $list_ref = shift;                                                                                     # test_overlaps
    for my $a (@$list_ref) {                                                                                  # test_overlaps
        for my $b (@$list_ref) {                                                                              # test_overlaps
            # See if the 5' end of $b overlaps with either end of $a                                          # test_overlaps
            $a->find_before($b);                                                                              # test_overlaps
            # See if the 3' end of $b overlaps with either end of $a                                          # test_overlaps
            $a->find_after($b);                                                                               # test_overlaps
        }                                                                                                     # test_overlaps
    }                                                                                                         # test_overlaps
}                                                                                                             # test_overlaps
###############################################################################################################
sub new_contigs{                                                                                              # new_contigs
    # This subroutine takes an array refernce as input, elements of the array are contig objects              # new_contigs
    #    For each of the contigs in the input array creates a new contig with the same name and sequence      # new_contigs
    #    Then tests their overlaps                                                                            # new_contigs
    my $old_ref = shift;                                                                                      # new_contigs
                                                                                                              # new_contigs
    # Creates a refernce to a new empty array                                                                 # new_contigs
    my $new_ref = [];                                                                                         # new_contigs
                                                                                                              # new_contigs
    # Create new contig (copy of the old, but with empty overlap lists)                                       # new_contigs
    for (@$old_ref) {                                                                                         # new_contigs
        my $name = $_->name();                                                                                # new_contigs
        my $seq = $_->seq();                                                                                  # new_contigs
        push @$new_ref, contig->new($name, $seq);                                                             # new_contigs
    }                                                                                                         # new_contigs
                                                                                                              # new_contigs
    # Test overlaps                                                                                           # new_contigs
    &test_overlaps($new_ref);                                                                                 # new_contigs
    return $new_ref;                                                                                          # new_contigs
}                                                                                                             # new_contigs
###############################################################################################################
sub merge_pair{                                                                                               # merge_pair
    # This subroutine takes two contigs and merges them into a single new contig                              # merge_pair
    #    Inputs:                                                                                              # merge_pair
    my ($a,         # The 5' contig object                                                                    # merge_pair
        $b,         # The 3' contig object                                                                    # merge_pair
        $overlap,   # The size of the overlap in basepairs                                                    # merge_pair
        $rev_a,     # The orientation of the 5' contig (true if reversed)                                     # merge_pair
        $rev_b      # The orientation of the 3' contig (true if reversed)                                     # merge_pair
                    ) = @_;                                                                                   # merge_pair
                                                                                                              # merge_pair
    # The new contigs name is going to be the 5' contig's name                                                # merge_pair
    my $name = $a->name();                                                                                    # merge_pair
                                                                                                              # merge_pair
    # The sequence of the new contig is a combination of the two sequences                                    # merge_pair
    my $seq;                                                                                                  # merge_pair
    #    First the sequence of the 5' contig in proper orientation                                            # merge_pair
    if ($rev_a) {                                                                                             # merge_pair
        $seq = $a->rev();                                                                                     # merge_pair
    } else {                                                                                                  # merge_pair
        $seq = $a->seq();                                                                                     # merge_pair
    }                                                                                                         # merge_pair
    #    Then the sequence of the 3' contig in proper orientation, but skipping the overlap region            # merge_pair
    if ($rev_b) {                                                                                             # merge_pair
        $seq .= substr $b->rev(), $overlap;                                                                   # merge_pair
    } else {                                                                                                  # merge_pair
        $seq .= substr $b->seq(), $overlap;                                                                   # merge_pair
    }                                                                                                         # merge_pair
                                                                                                              # merge_pair
    # Create the new contig and return it                                                                     # merge_pair
    return contig->new($name, $seq);                                                                          # merge_pair
}                                                                                                             # merge_pair
###############################################################################################################
sub overlap{                                                                                                  # overlap
    # This subroutine takes two strings and checks if the start of the first overlaps with the end of the     # overlap
    #    second string. It returns the sequence of the overlap (empty if nothing is found)                    # overlap
    # This subroutine runs in a recursive manner                                                              # overlap
    my ($left_ref, $right_ref) = @_;                                                                          # overlap
    my $left = $$left_ref;                                                                                    # overlap
    my $right = $$right_ref;                                                                                  # overlap
                                                                                                              # overlap
    # If the two strings are equal return it                                                                  # overlap
    if ($right eq $left) {                                                                                    # overlap
        return $right;                                                                                        # overlap
                                                                                                              # overlap
    # If one is empty return empty                                                                            # overlap
    } elsif ((! $right) || (! $left)){                                                                        # overlap
        return;                                                                                               # overlap
                                                                                                              # overlap
    # ELSE reduce the string sizes and recurse                                                                # overlap
    } else {                                                                                                  # overlap
        # Get the first $len characters                                                                       # overlap
        my $min = substr $right, 0, $len;                                                                     # overlap
                                                                                                              # overlap
        # Match the minimal overlap and keep the postmatch data                                               # overlap
        if ($left =~ /$min/p) {                                                                               # overlap
            # Store the postmatch region                                                                      # overlap
            my $post = ${^POSTMATCH};                                                                         # overlap
                                                                                                              # overlap
            # If there is no postmatched region than the minimal sequence matched the end of the left         # overlap
            #    string so return the minimal sequence                                                        # overlap
            unless ($post) {                                                                                  # overlap
                return $min;                                                                                  # overlap
            } else {                                                                                          # overlap
                # Check if the match and postmatch matches with the start of the right string                 # overlap
                if ($right =~ /^$min$post/) {                                                                 # overlap
                    # Return overlap if yes                                                                   # overlap
                    return $min . $post;                                                                      # overlap
                } else {                                                                                      # overlap
                    # Check if the search term matches inside the previous hit                                # overlap
                    my $str = substr($min, 1) . $post;                         # overlap
                    # If yes then for the next iteration reduce the size of the string by one                 # overlap
                    if ($str =~ /$min/) {                                                                     # overlap
                        my $next = substr($min, 1) . $post;                                         # overlap
                        return &overlap(\$next, \$right);                                                     # overlap
                    } else {                                                                                  # overlap
                        # Use only the postmatch, because there is no nearer hit possible                     # overlap
                        return &overlap(\$post, \$right);                                                     # overlap
                    }                                                                                         # overlap
                }                                                                                             # overlap
            }                                                                                                 # overlap
        } else {                                                                                              # overlap
            # If the minimal didn't match at all then return empty                                            # overlap
            return;                                                                                           # overlap
        }                                                                                                     # overlap
    }                                                                                                         # overlap
}                                                                                                             # overlap
#############################################################################################################xx

#############################################################################################
package contig;                                                                             # package contig
# Contig objects                                                                            # package contig
#    stores the name of the contig                                                          # package contig
#    the sequence of the contig                                                             # package contig
#    the reverse complement of the sequence                                                 # package contig
#    an array of the contigs that overlap with the start                                    # package contig
                                                                                            # package contig
sub new{                                                                                    # package contig
    # Create a new contig                                                                   # package contig
    my $class = shift;                                                                      # package contig
    my ($name, $seq) = @_;                                                                  # package contig
    my $rev = reverse $seq;                                                                 # package contig
    $rev =~ tr/ACTG/TGAC/;                                                                  # package contig
    my $self = bless {                                                                      # package contig
                       name => $name,   # Name of the contig                                # package contig
                       seq => $seq,     # Sequence of the contig                            # package contig
                       rev => $rev,     # Reverse complement of the sequence                # package contig
                       before => [],    # List of overlaps for 5' end                       # package contig
                       after => [],     # List of overlaps for 3' end                       # package contig
                                        }, $class;                                          # package contig
    return $self;                                                                           # package contig
}                                                                                           # package contig
                                                                                            # package contig
sub name{                                                                                   # package contig
    # get the name of the contig                                                            # package contig
    my $self = shift;                                                                       # package contig
    return $$self{"name"};                                                                  # package contig
}                                                                                           # package contig
                                                                                            # package contig
sub seq{                                                                                    # package contig
    # Get the sequence of the contig                                                        # package contig
    my $self = shift;                                                                       # package contig
    return $$self{"seq"};                                                                   # package contig
}                                                                                           # package contig
                                                                                            # package contig
sub rev{                                                                                    # package contig
    # Get the reverse complement of the sequence of the contig                              # package contig
    my $self = shift;                                                                       # package contig
    return $$self{"rev"};                                                                   # package contig
}                                                                                           # package contig
                                                                                            # package contig
sub find_before{                                                                            # package contig
    # This subroutine takes two contigs as input: itself and a second contig                # package contig
    my $self = shift;                                                                       # package contig
    my $before = shift;                                                                     # package contig
                                                                                            # package contig
    # A variable to store the overlap                                                       # package contig
    my $overlap;                                                                            # package contig
    # If the second contig is the same as this contig then make the left string shorter     # package contig
    #    Otherwise it would say that it overlaps completely                                 # package contig
    # Check overlap                                                                         # package contig
    if ($self->name() eq $before->name()) {                                                 # package contig
        $overlap = &main::overlap(\(substr $before->seq(), $len), \$self->seq());           # package contig
    } else {                                                                                # package contig
        $overlap = &main::overlap(\$before->seq(), \$self->seq());                          # package contig
    }                                                                                       # package contig
                                                                                            # package contig
    # If there was an overlap found between them then save it to the array                  # package contig
    if ($overlap) {                                                                         # package contig
        push @{ $$self{"before"} }, [length $overlap, $before, "+"];                        # package contig
    } else {                                                                                # package contig
        # ELSE try if they overlap if the second one is reversed                            # package contig
        $overlap = &main::overlap(\$before->rev(), \$self->seq());                          # package contig
        if ($overlap) {                                                                     # package contig
            push @{ $$self{"before"} }, [length $overlap, $before, "-"];                    # package contig
        }                                                                                   # package contig
    }                                                                                       # package contig
}                                                                                           # package contig
                                                                                            # package contig
sub find_after{                                                                             # package contig
    # This subroutine takes two contigs as input: itself and a second contig                # package contig
    my $self = shift;                                                                       # package contig
    my $after = shift;                                                                      # package contig
                                                                                            # package contig
    # A variable to store the overlap                                                       # package contig
    my $overlap;                                                                            # package contig
    # If the second contig is the same as this contig then make the left string shorter     # package contig
    #    Otherwise it would say that it overlaps completely                                 # package contig
    # Check overlap                                                                         # package contig
    if ($self->name() eq $after->name()) {                                                  # package contig
        $overlap = &main::overlap(\(substr $self->seq(), $len), \$after->seq());            # package contig
    } else {                                                                                # package contig
        $overlap = &main::overlap(\$self->seq(), \$after->seq());                           # package contig
    }                                                                                       # package contig
                                                                                            # package contig
    # If there was an overlap found between them then save it to the array                  # package contig
    if ($overlap) {                                                                         # package contig
        push @{ $$self{"after"} }, [length $overlap, $after, "+"];                          # package contig
    } else {                                                                                # package contig
        # ELSE try if they overlap if the second one is reversed                            # package contig
        $overlap = &main::overlap(\$self->seq(), \$after->rev());                           # package contig
        if ($overlap) {                                                                     # package contig
            push @{ $$self{"after"} }, [length $overlap, $after, "-"];                      # package contig
        }                                                                                   # package contig
    }                                                                                       # package contig
}                                                                                           # package contig
                                                                                            # package contig
sub get_before{                                                                             # package contig
    # Get the list of overlaps for 5' end of the contig                                     # package contig
    #    each element an array reference                                                    # package contig
    #        [0] the size of the overlap                                                    # package contig
    #        [1] the contig object                                                          # package contig
    #        [2] the orientation (+/-) of the overlap                                       # package contig
    my $self = shift;                                                                       # package contig
    return $self->{"before"};                                                               # package contig
}                                                                                           # package contig
                                                                                            # package contig
sub get_after{                                                                              # package contig
    # Get the list of overlaps for 3' end of the contig                                     # package contig
    #    each element an array reference                                                    # package contig
    #        [0] the size of the overlap                                                    # package contig
    #        [1] the contig object                                                          # package contig
    #        [2] the orientation (+/-) of the overlap                                       # package contig
    my $self = shift;                                                                       # package contig
    return $self->{"after"};                                                                # package contig
}                                                                                           # package contig
#############################################################################################

###########
# The End #
###########
